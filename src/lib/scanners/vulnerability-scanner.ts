import { exec } from "child_process"
import { promisify } from "util"
import { db } from "@/lib/db"

const execAsync = promisify(exec)

export interface ScanResult {
  scanId: string
  output: string
  progress: number
  status: string
  vulnerabilities?: any[]
}

export interface Vulnerability {
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" | "INFO"
  type: string
  title: string
  description?: string
  solution?: string
  reference?: string
  location?: string
}

export class VulnerabilityScanner {
  private io: any
  private scanTimeout: NodeJS.Timeout | null = null

  constructor(io: any) {
    this.io = io
  }

  async startScan(scanId: string, url: string, scanType: string) {
    try {
      // Update scan status to running
      await db.scan.update({
        where: { id: scanId },
        data: { status: "RUNNING", startedAt: new Date() },
      })

      // Set timeout for the entire scan (30 minutes)
      this.scanTimeout = setTimeout(
        () => {
          this.handleScanTimeout(scanId)
        },
        30 * 60 * 1000,
      )

      // Emit initial update
      this.emitUpdate(scanId, {
        scanId,
        output: `üöÄ Starting ${scanType} scan for ${url}...\n`,
        progress: 0,
        status: "RUNNING",
      })

      // Emit connection established message
      setTimeout(() => {
        this.emitUpdate(scanId, {
          scanId,
          output: `‚úÖ Connected to scan server\n`,
          progress: 5,
          status: "RUNNING",
        })
      }, 500)

      // Emit initialization message
      setTimeout(() => {
        this.emitUpdate(scanId, {
          scanId,
          output: `üîß Initializing scan environment...\n`,
          progress: 10,
          status: "RUNNING",
        })
      }, 1000)

      let vulnerabilities: Vulnerability[] = []
      let output = ""

      // Emit starting specific scan message
      setTimeout(() => {
        this.emitUpdate(scanId, {
          scanId,
          output: `üéØ Starting ${scanType} scan...\n`,
          progress: 15,
          status: "RUNNING",
        })
      }, 1500)

      switch (scanType) {
        case "NMAP":
          output = await this.runNmapScan(scanId, url)
          vulnerabilities = this.parseNmapOutput(output)
          break
        case "NIKTO":
          output = await this.runNiktoScan(scanId, url)
          vulnerabilities = this.parseNiktoOutput(output)
          break
        case "SSL_CHECK":
          output = await this.runSSLCheck(scanId, url)
          vulnerabilities = this.parseSSLOutput(output)
          break
        case "HEADER_ANALYSIS":
          output = await this.runHeaderAnalysis(scanId, url)
          vulnerabilities = this.parseHeaderOutput(output)
          break
        case "NUCLEI":
          output = await this.runNucleiScan(scanId, url)
          vulnerabilities = this.parseNucleiOutput(output)
          break
        case "SQLMAP":
          output = await this.runSqlmapScan(scanId, url)
          vulnerabilities = this.parseSqlmapOutput(output)
          break
        case "VULS":
          output = await this.runVulsScan(scanId, url)
          vulnerabilities = this.parseVulsOutput(output)
          break
        case "COMMIX":
          output = await this.runCommixScan(scanId, url)
          vulnerabilities = this.parseCommixOutput(output)
          break
        case "NETTACKER":
          output = await this.runNettackerScan(scanId, url)
          vulnerabilities = this.parseNettackerOutput(output)
          break
        case "CORSY":
          output = await this.runCorsyScan(scanId, url)
          vulnerabilities = this.parseCorsyOutput(output)
          break
        case "CSP_EVAL":
          output = await this.runCspEvalScan(scanId, url)
          vulnerabilities = this.parseCspOutput(output)
          break
        case "OPEN_REDIRECT_CHECK":
          output = await this.runOpenRedirectCheck(scanId, url)
          vulnerabilities = this.parseOpenRedirectOutput(output)
          break
        case "EXPOSED_FILES":
          output = await this.runExposedFilesCheck(scanId, url)
          vulnerabilities = this.parseExposedFilesOutput(output)
          break
        case "FULL_SCAN":
          output = await this.runFullScan(scanId, url)
          vulnerabilities = this.parseFullScanOutput(output)
          break
        default:
          throw new Error(`Unknown scan type: ${scanType}`)
      }

      // Clear timeout since scan completed successfully
      if (this.scanTimeout) {
        clearTimeout(this.scanTimeout)
        this.scanTimeout = null
      }

      // Emit completion message
      this.emitUpdate(scanId, {
        scanId,
        output: `üìä Compiling results...\n`,
        progress: 95,
        status: "RUNNING",
      })

      // Save vulnerabilities to database
      if (vulnerabilities.length > 0) {
        this.emitUpdate(scanId, {
          scanId,
          output: `üíæ Saving ${vulnerabilities.length} detected vulnerabilities to database...\n`,
          progress: 97,
          status: "RUNNING",
          vulnerabilities,
        })
      }

      for (const vuln of vulnerabilities) {
        await db.vulnerability.create({
          data: {
            scanId,
            ...vuln,
          },
        })
      }

      // Update scan as completed
      await db.scan.update({
        where: { id: scanId },
        data: {
          status: "COMPLETED",
          completedAt: new Date(),
          results: JSON.stringify({ output, vulnerabilities }),
        },
      })

      // Explicit emit for clients listening to scanComplete
      try {
        if (this.io?.to) {
          this.io.to(scanId).emit("scanComplete", {
            scanId,
            results: { output, vulnerabilities },
          })
        }
      } catch (e) {
        console.log("[v0] socket scanComplete emit failed:", (e as any)?.message || e)
      }

      // Emit completion
      this.emitUpdate(scanId, {
        scanId,
        output: `‚úÖ Scan completed successfully!\nüìà Found ${vulnerabilities.length} vulnerabilities\n`,
        progress: 100,
        status: "COMPLETED",
        vulnerabilities,
      })
    } catch (error) {
      console.error("Scan failed:", error)

      // Clear timeout
      if (this.scanTimeout) {
        clearTimeout(this.scanTimeout)
        this.scanTimeout = null
      }

      // Update scan as failed
      await db.scan.update({
        where: { id: scanId },
        data: {
          status: "FAILED",
          completedAt: new Date(),
          errorMessage: error instanceof Error ? error.message : "Unknown error",
        },
      })

      // Emit error
      const msg = `‚ùå Scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
      try {
        if (this.io?.to) {
          this.io.to(scanId).emit("scanError", { scanId, error: msg.trim() })
        }
      } catch (e) {
        console.log("[v0] socket scanError emit failed:", (e as any)?.message || e)
      }
      this.emitUpdate(scanId, {
        scanId,
        output: msg,
        progress: 0,
        status: "FAILED",
      })
    }
  }

  private async handleScanTimeout(scanId: string) {
    console.log(`Scan ${scanId} timed out`)

    try {
      await db.scan.update({
        where: { id: scanId },
        data: {
          status: "FAILED",
          completedAt: new Date(),
          errorMessage: "Scan timed out after 30 minutes",
        },
      })

      this.emitUpdate(scanId, {
        scanId,
        output: "Scan timed out after 30 minutes\n",
        progress: 0,
        status: "FAILED",
      })
    } catch (error) {
      console.error("Failed to handle scan timeout:", error)
    }
  }

  private async runNmapScan(scanId: string, url: string): Promise<string> {
    const hostname = new URL(url).hostname

    // Check if nmap is available
    try {
      await execAsync("which nmap")
    } catch {
      // Return simulated output for demonstration purposes
      const simulatedOutput = `# Nmap Simulation (nmap not installed)
# Starting Nmap Simulation for ${hostname}
# Port scan results (simulated):
22/tcp   open  ssh
80/tcp   open  http
443/tcp open  https

# Service detection (simulated):
22/tcp   open  ssh     OpenSSH 7.4
80/tcp   open  http    Apache 2.4.41
443/tcp open  https   Apache 2.4.41

# OS detection (simulated):
OS details: Linux 3.2 - 4.9

# Network Distance: 2 hops
# Nmap done: 1 IP address (1 host up) scanned in 5.13 seconds
`

      this.emitUpdate(scanId, {
        scanId,
        output: `Running Nmap simulation (nmap not installed)\n${simulatedOutput}`,
        progress: 90,
        status: "RUNNING",
      })

      return simulatedOutput
    }

    const command = `nmap -sV -sC -O ${hostname}`

    this.emitUpdate(scanId, {
      scanId,
      output: `Running Nmap scan: ${command}\n`,
      progress: 10,
      status: "RUNNING",
    })

    try {
      const { stdout, stderr } = await execAsync(command, { timeout: 300000 }) // 5 minute timeout

      this.emitUpdate(scanId, {
        scanId,
        output: stdout + stderr,
        progress: 90,
        status: "RUNNING",
      })

      return stdout + stderr
    } catch (error: any) {
      const errorMessage = error.message || "Nmap scan failed"
      this.emitUpdate(scanId, {
        scanId,
        output: `Nmap scan failed: ${errorMessage}\n`,
        progress: 0,
        status: "FAILED",
      })
      throw new Error(errorMessage)
    }
  }

  private async runNiktoScan(scanId: string, url: string): Promise<string> {
    // Check if nikto is available
    try {
      await execAsync("which nikto")
    } catch {
      // Return simulated output for demonstration purposes
      const simulatedOutput = `# Nikto Simulation (nikto not installed)
# Starting Nikto simulation for ${url}
# Target IP:          127.0.0.1
# Target Hostname:    ${new URL(url).hostname}
# Target Port:        80
# Start Time:         ${new Date().toISOString()}

# Server: Apache/2.4.41
# Retrieved x-powered-by header: PHP/7.4.3
# The anti-clickjacking X-Frame-Options header is not present.
# The X-XSS-Protection header is not defined.
# The X-Content-Type-Options header is not set.
# Web Server returns a valid HTTP 200 for non-existent files.
# Allowed HTTP Methods: GET, HEAD, POST, OPTIONS

# Simulation completed: 1 host tested
# Server detected: Apache
# 0 potential vulnerabilities found (simulation mode)
`

      this.emitUpdate(scanId, {
        scanId,
        output: `Running Nikto simulation (nikto not installed)\n${simulatedOutput}`,
        progress: 90,
        status: "RUNNING",
      })

      return simulatedOutput
    }

    const command = `nikto -h ${url} -Format txt`

    this.emitUpdate(scanId, {
      scanId,
      output: `Running Nikto scan: ${command}\n`,
      progress: 10,
      status: "RUNNING",
    })

    try {
      const { stdout, stderr } = await execAsync(command, { timeout: 600000 }) // 10 minute timeout

      this.emitUpdate(scanId, {
        scanId,
        output: stdout + stderr,
        progress: 90,
        status: "RUNNING",
      })

      return stdout + stderr
    } catch (error: any) {
      const errorMessage = error.message || "Nikto scan failed"
      this.emitUpdate(scanId, {
        scanId,
        output: `Nikto scan failed: ${errorMessage}\n`,
        progress: 0,
        status: "FAILED",
      })
      throw new Error(errorMessage)
    }
  }

  private async runSSLCheck(scanId: string, url: string): Promise<string> {
    const hostname = new URL(url).hostname

    // Check if openssl is available
    try {
      await execAsync("which openssl")
    } catch {
      // Return simulated output for demonstration purposes
      const simulatedOutput = `# SSL/TLS Simulation (openssl not installed)
# SSL Certificate Analysis for ${hostname}:443

# Certificate Information (simulated):
Subject: CN = ${hostname}
Issuer: CN = Let's Encrypt Authority X3
Serial number: 03ABC123456789DEF
Not Before: ${new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString()}
Not After: ${new Date(Date.now() + 60 * 24 * 60 * 60 * 1000).toISOString()}

# Certificate Chain (simulated):
Certificate chain
 0 s:CN = ${hostname}
   i:CN = Let's Encrypt Authority X3
 1 s:CN = Let's Encrypt Authority X3
   i:CN = DST Root CA X3

# SSL/TLS Protocol Support (simulated):
TLS 1.3: Supported
TLS 1.2: Supported
TLS 1.1: Not supported
TLS 1.0: Not supported

# Cipher Suites (simulated):
TLS_AES_256_GCM_SHA384
TLS_CHACHA20_POLY1305_SHA256
TLS_AES_128_GCM_SHA256

# Security Assessment (simulated):
‚úì Valid certificate from trusted CA
‚úì Certificate not expired
‚úì Supports strong cipher suites
‚úì HSTS enabled
‚ö† Certificate expires in 60 days

# Simulation completed successfully
`

      this.emitUpdate(scanId, {
        scanId,
        output: `Running SSL/TLS simulation (openssl not installed)\n${simulatedOutput}`,
        progress: 90,
        status: "RUNNING",
      })

      return simulatedOutput
    }

    const command = `openssl s_client -connect ${hostname}:443 -showcerts`

    this.emitUpdate(scanId, {
      scanId,
      output: `Running SSL/TLS check: ${command}\n`,
      progress: 10,
      status: "RUNNING",
    })

    try {
      const { stdout, stderr } = await execAsync(command, { timeout: 60000 }) // 1 minute timeout

      this.emitUpdate(scanId, {
        scanId,
        output: stdout + stderr,
        progress: 90,
        status: "RUNNING",
      })

      return stdout + stderr
    } catch (error: any) {
      const errorMessage = error.message || "SSL check failed"
      this.emitUpdate(scanId, {
        scanId,
        output: `SSL check failed: ${errorMessage}\n`,
        progress: 0,
        status: "FAILED",
      })
      throw new Error(errorMessage)
    }
  }

  private async runHeaderAnalysis(scanId: string, url: string): Promise<string> {
    // Check if curl is available
    try {
      await execAsync("which curl")
    } catch {
      // Return simulated output for demonstration purposes
      const simulatedOutput = `# Security Headers Analysis (curl not installed)
# HTTP Headers for ${url}

# Response Headers (simulated):
HTTP/2 200 
server: Apache/2.4.41
content-type: text/html; charset=UTF-8
date: ${new Date().toUTCString()}
vary: Accept-Encoding
x-powered-by: PHP/7.4.3
set-cookie: session_id=abc123; path=/; HttpOnly; Secure

# Security Headers Analysis:
‚úì Content-Security-Policy: default-src 'self'
‚úì X-Frame-Options: DENY
‚úì X-Content-Type-Options: nosniff
‚úì Strict-Transport-Security: max-age=31536000; includeSubDomains
‚úì X-XSS-Protection: 1; mode=block
‚úì Referrer-Policy: strict-origin-when-cross-origin
‚úì Permissions-Policy: camera=(), microphone=(), geolocation=()

# Missing Security Headers:
‚ö† Expect-CT: Not implemented
‚ö† Clear-Site-Data: Not implemented

# Cookie Security:
‚úì HttpOnly flag set
‚úì Secure flag set
‚ö† SameSite attribute not set

# Overall Security Score: 8/10
# Recommendations: Implement missing security headers for enhanced protection

# Analysis completed successfully
`

      this.emitUpdate(scanId, {
        scanId,
        output: `Running security headers analysis (curl not installed)\n${simulatedOutput}`,
        progress: 90,
        status: "RUNNING",
      })

      return simulatedOutput
    }

    const command = `curl -I ${url}`

    this.emitUpdate(scanId, {
      scanId,
      output: `Running security headers analysis: ${command}\n`,
      progress: 10,
      status: "RUNNING",
    })

    try {
      const { stdout } = await execAsync(command, { timeout: 30000 }) // 30 second timeout

      this.emitUpdate(scanId, {
        scanId,
        output: stdout,
        progress: 90,
        status: "RUNNING",
      })

      return stdout
    } catch (error: any) {
      const errorMessage = error.message || "Header analysis failed"
      this.emitUpdate(scanId, {
        scanId,
        output: `Header analysis failed: ${errorMessage}\n`,
        progress: 0,
        status: "FAILED",
      })
      throw new Error(errorMessage)
    }
  }

  private async runCspEvalScan(scanId: string, url: string): Promise<string> {
    // Try to use curl for headers, otherwise simulate
    try {
      await execAsync("which curl")
    } catch {
      const simulated = `# CSP Evaluation (simulated)
Target: ${url}
Result: Content-Security-Policy header not found
Advisories:
- Missing CSP reduces protection against XSS.
`
      this.emitUpdate(scanId, { scanId, output: simulated, progress: 55, status: "RUNNING" })
      return simulated
    }

    const cmd = `curl -sI ${url}`
    this.emitUpdate(scanId, { scanId, output: `Evaluating CSP via: ${cmd}\n`, progress: 54, status: "RUNNING" })
    try {
      const { stdout } = await execAsync(cmd, { timeout: 30000 })
      const headerBlock = stdout
      const cspLine =
        headerBlock.split(/\r?\n/).find((l) => /^content-security-policy/i.test(l)) ||
        "Content-Security-Policy: <absent>"
      const analysis: string[] = []
      if (/absent/i.test(cspLine)) {
        analysis.push("CSP_MISSING")
      } else {
        if (/unsafe-inline/i.test(cspLine)) analysis.push("CSP_WEAK_UNSAFE_INLINE")
        if (/unsafe-eval/i.test(cspLine)) analysis.push("CSP_WEAK_UNSAFE_EVAL")
        if (/\*\.?\s*|default-src\s*'\*'|script-src\s*'\*'/i.test(cspLine)) analysis.push("CSP_OVERLY_PERMISSIVE")
      }
      const out = `# CSP Evaluation
${cspLine}
Findings: ${analysis.join(", ") || "NONE"}
`
      this.emitUpdate(scanId, { scanId, output: out, progress: 56, status: "RUNNING" })
      return out
    } catch (e: any) {
      const msg = `CSP evaluation failed: ${e?.message || "Unknown error"}`
      this.emitUpdate(scanId, { scanId, output: msg + "\n", progress: 56, status: "RUNNING" })
      return msg
    }
  }

  private async runOpenRedirectCheck(scanId: string, url: string): Promise<string> {
    // Attempt a basic heuristic by probing common redirect params. If curl missing, simulate.
    try {
      await execAsync("which curl")
    } catch {
      const simulated = `# Open Redirect Check (simulated)
Target: ${url}
Tests: next, redirect, url, r
Result: No conclusive evidence (simulation)
`
      this.emitUpdate(scanId, { scanId, output: simulated, progress: 84, status: "RUNNING" })
      return simulated
    }

    const candidates = ["next", "redirect", "url", "r"]
    let out = `# Open Redirect Check\nTarget: ${url}\n`
    for (const p of candidates) {
      const testUrl = `${url}${url.includes("?") ? "&" : "?"}${p}=https://example.com`
      const cmd = `curl -s -o /dev/null -w "%{http_code} %{redirect_url}" -L "${testUrl}"`
      try {
        const { stdout } = await execAsync(cmd, { timeout: 30000 })
        out += `Param: ${p} -> ${stdout}\n`
        if (stdout.includes("https://example.com")) {
          out += `POTENTIAL_OPEN_REDIRECT via param "${p}"\n`
        }
      } catch (e: any) {
        out += `Param: ${p} -> error: ${e?.message || "unknown"}\n`
      }
    }
    this.emitUpdate(scanId, { scanId, output: out, progress: 86, status: "RUNNING" })
    return out
  }

  private async runExposedFilesCheck(scanId: string, url: string): Promise<string> {
    const paths = ["/.env", "/.git/HEAD", "/backup.zip", "/config.php", "/robots.txt"]
    try {
      await execAsync("which curl")
    } catch {
      const simulated = `# Exposed Files Check (simulated)
Target: ${url}
EXPOSED_NONE
`
      this.emitUpdate(scanId, { scanId, output: simulated, progress: 90, status: "RUNNING" })
      return simulated
    }

    let out = `# Exposed Files Check\nTarget: ${url}\n`
    for (const p of paths) {
      const normalized = url.replace(/\/$/, "")
      const cmd = `curl -s -o /dev/null -w "%{http_code}" "${normalized}${p}"`
      try {
        const { stdout } = await execAsync(cmd, { timeout: 20000 })
        const code = Number.parseInt((stdout || "0").trim(), 10)
        out += `${p} -> ${code}\n`
        if (code === 200) {
          out += `EXPOSED: ${p}\n`
        }
      } catch (e: any) {
        out += `${p} -> error: ${e?.message || "unknown"}\n`
      }
    }
    this.emitUpdate(scanId, { scanId, output: out, progress: 90, status: "RUNNING" })
    return out
  }

  private async runFullScan(scanId: string, url: string): Promise<string> {
    let fullOutput = ""

    fullOutput += "=== Starting Full Comprehensive Scan ===\n\n"

    // 1) Nmap
    fullOutput += "1. Running Network Scan (Nmap)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 5, status: "RUNNING" })
    try {
      const nmapOutput = await this.runNmapScan(scanId, url)
      fullOutput += nmapOutput + "\n"
    } catch (error) {
      fullOutput += `Nmap scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 2) Nikto
    fullOutput += "\n2. Running Web Server Scan (Nikto)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 12, status: "RUNNING" })
    try {
      const niktoOutput = await this.runNiktoScan(scanId, url)
      fullOutput += niktoOutput + "\n"
    } catch (error) {
      fullOutput += `Nikto scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 3) Nuclei
    fullOutput += "\n3. Running Vulnerability Scan (Nuclei)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 22, status: "RUNNING" })
    try {
      const nucleiOutput = await this.runNucleiScan(scanId, url)
      fullOutput += nucleiOutput + "\n"
    } catch (error) {
      fullOutput += `Nuclei scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 4) SSL
    fullOutput += "\n4. Running SSL/TLS Security Check...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 32, status: "RUNNING" })
    try {
      const sslOutput = await this.runSSLCheck(scanId, url)
      fullOutput += sslOutput + "\n"
    } catch (error) {
      fullOutput += `SSL check failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 5) Header Analysis
    fullOutput += "\n5. Running Security Headers Analysis...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 42, status: "RUNNING" })
    try {
      const headerOutput = await this.runHeaderAnalysis(scanId, url)
      fullOutput += headerOutput + "\n"
    } catch (error) {
      fullOutput += `Header analysis failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 6) CSP Evaluation
    fullOutput += "\n6. Evaluating Content Security Policy (CSP)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 52, status: "RUNNING" })
    try {
      const cspOutput = await this.runCspEvalScan(scanId, url)
      fullOutput += cspOutput + "\n"
    } catch (error) {
      fullOutput += `CSP evaluation failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 7) SQLMap
    fullOutput += "\n7. Running SQL Injection Scan (SQLMap)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 62, status: "RUNNING" })
    try {
      const sqlmapOutput = await this.runSqlmapScan(scanId, url)
      fullOutput += sqlmapOutput + "\n"
    } catch (error) {
      fullOutput += `SQLMap scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 8) Corsy
    fullOutput += "\n8. Running CORS Misconfiguration Scan (Corsy)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 72, status: "RUNNING" })
    try {
      const corsyOutput = await this.runCorsyScan(scanId, url)
      fullOutput += corsyOutput + "\n"
    } catch (error) {
      fullOutput += `Corsy scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 9) Open Redirect Check
    fullOutput += "\n9. Checking for Open Redirects...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 82, status: "RUNNING" })
    try {
      const openRedirectOutput = await this.runOpenRedirectCheck(scanId, url)
      fullOutput += openRedirectOutput + "\n"
    } catch (error) {
      fullOutput += `Open redirect check failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 10) Exposed Files
    fullOutput += "\n10. Checking for Exposed Files...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 88, status: "RUNNING" })
    try {
      const exposedOutput = await this.runExposedFilesCheck(scanId, url)
      fullOutput += exposedOutput + "\n"
    } catch (error) {
      fullOutput += `Exposed files check failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 11) Nettacker
    fullOutput += "\n11. Running Network Attack Scan (Nettacker)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 94, status: "RUNNING" })
    try {
      const nettackerOutput = await this.runNettackerScan(scanId, url)
      fullOutput += nettackerOutput + "\n"
    } catch (error) {
      fullOutput += `Nettacker scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    // 12) Commix
    fullOutput += "\n12. Running Command Injection Scan (Commix)...\n"
    this.emitUpdate(scanId, { scanId, output: fullOutput, progress: 98, status: "RUNNING" })
    try {
      const commixOutput = await this.runCommixScan(scanId, url)
      fullOutput += commixOutput + "\n"
    } catch (error) {
      fullOutput += `Commix scan failed: ${error instanceof Error ? error.message : "Unknown error"}\n`
    }

    fullOutput += "\n=== Full Scan Completed ===\n"

    this.emitUpdate(scanId, {
      scanId,
      output: fullOutput,
      progress: 100,
      status: "COMPLETED",
    })

    return fullOutput
  }

  private async runNucleiScan(scanId: string, url: string): Promise<string> {
    // Check if nuclei is available
    try {
      await execAsync("which nuclei")
    } catch {
      throw new Error("Nuclei is not installed on the server")
    }

    const command = `nuclei -u ${url} -silent`

    this.emitUpdate(scanId, {
      scanId,
      output: `Running Nuclei scan: ${command}\n`,
      progress: 10,
      status: "RUNNING",
    })

    try {
      const { stdout, stderr } = await execAsync(command, { timeout: 600000 }) // 10 minute timeout

      this.emitUpdate(scanId, {
        scanId,
        output: stdout + stderr,
        progress: 90,
        status: "RUNNING",
      })

      return stdout + stderr
    } catch (error: any) {
      const errorMessage = error.message || "Nuclei scan failed"
      this.emitUpdate(scanId, {
        scanId,
        output: `Nuclei scan failed: ${errorMessage}\n`,
        progress: 0,
        status: "FAILED",
      })
      throw new Error(errorMessage)
    }
  }

  private async runSqlmapScan(scanId: string, url: string): Promise<string> {
    try {
      await execAsync("which sqlmap")
    } catch {
      throw new Error("SQLMap is not installed on the server")
    }

    const command = `sqlmap -u ${url} --batch --random-agent`

    this.emitUpdate(scanId, {
      scanId,
      output: `Running SQLMap scan: ${command}\n`,
      progress: 10,
      status: "RUNNING",
    })

    try {
      const { stdout, stderr } = await execAsync(command, { timeout: 900000 }) // 15 minute timeout
      this.emitUpdate(scanId, {
        scanId,
        output: stdout + stderr,
        progress: 90,
        status: "RUNNING",
      })
      return stdout + stderr
    } catch (error: any) {
      const errorMessage = error.message || "SQLMap scan failed"
      this.emitUpdate(scanId, {
        scanId,
        output: `SQLMap scan failed: ${errorMessage}\n`,
        progress: 0,
        status: "FAILED",
      })
      throw new Error(errorMessage)
    }
  }

  private async runVulsScan(scanId: string, url: string): Promise<string> {
    // Placeholder for Vuls scan
    return `# Vuls Scan Placeholder\nTarget: ${url}\n`
  }

  private async runCommixScan(scanId: string, url: string): Promise<string> {
    // Placeholder for Commix scan
    return `# Commix Scan Placeholder\nTarget: ${url}\n`
  }

  private async runNettackerScan(scanId: string, url: string): Promise<string> {
    // Placeholder for Nettacker scan
    return `# Nettacker Scan Placeholder\nTarget: ${url}\n`
  }

  private async runCorsyScan(scanId: string, url: string): Promise<string> {
    // Placeholder for Corsy scan
    return `# Corsy Scan Placeholder\nTarget: ${url}\n`
  }

  private parseNmapOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Nmap output
    return []
  }

  private parseNiktoOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Nikto output
    return []
  }

  private parseSSLOutput(output: string): Vulnerability[] {
    // Placeholder for parsing SSL output
    return []
  }

  private parseHeaderOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Header output
    return []
  }

  private parseNucleiOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Nuclei output
    return []
  }

  private parseSqlmapOutput(output: string): Vulnerability[] {
    // Placeholder for parsing SQLMap output
    return []
  }

  private parseVulsOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Vuls output
    return []
  }

  private parseCommixOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Commix output
    return []
  }

  private parseNettackerOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Nettacker output
    return []
  }

  private parseCorsyOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Corsy output
    return []
  }

  private parseCspOutput(output: string): Vulnerability[] {
    // Placeholder for parsing CSP output
    return []
  }

  private parseOpenRedirectOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Open Redirect output
    return []
  }

  private parseExposedFilesOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Exposed Files output
    return []
  }

  private parseFullScanOutput(output: string): Vulnerability[] {
    // Placeholder for parsing Full Scan output
    return []
  }

  private emitUpdate(scanId: string, result: ScanResult) {
    // Existing logging
    console.log(`Emitting update for scan ${scanId}:`, result)

    // If a socket server is available, broadcast updates to the scan room
    try {
      if (this.io?.to) {
        this.io.to(scanId).emit("scanUpdate", result)
        if (result.status === "COMPLETED") {
          // Provide a minimal completion payload as some clients listen for this explicit event
          this.io.to(scanId).emit("scanComplete", {
            scanId,
            results: { output: result.output, vulnerabilities: result.vulnerabilities || [] },
          })
        }
        if (result.status === "FAILED") {
          this.io.to(scanId).emit("scanError", { scanId, error: (result.output || "Scan failed").toString() })
        }
      }
    } catch (e) {
      console.log("[v0] socket emit failed:", (e as any)?.message || e)
    }
  }
}
