# Security Tools Installation Dockerfile
FROM archlinux:latest as tools-builder

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive

# Copy and run strap.sh script before installing packages
COPY scripts/strap.sh /tmp/strap.sh
RUN chmod +x /tmp/strap.sh && /tmp/strap.sh

# Install basic dependencies and update system
RUN pacman -Syu --noconfirm && \
    pacman -S --noconfirm --needed \
        base-devel \
        git \
        curl \
        wget \
        sudo \
        python \
        python-pip \
        python-setuptools \
        python-yaml \
        python-beautifulsoup4 \
        python-paramiko \
        python-scapy \
        ruby \
        go \
        rust \
        nmap \
        openssl \
        sqlite \
        which \
        gawk \
        grep \
        sed \
        coreutils \
        findutils \
        procps-ng

# Ensure Go workspace and bin are available to all RUN steps
ENV GOPATH=/go
ENV PATH=/go/bin:${PATH}

# Install Python dependencies (using --break-system-packages for externally managed environment)
# Create a helper script to check and install pip packages
RUN echo '#!/bin/bash' > /tmp/install_pip_package.sh && \
    echo 'package="$1"' >> /tmp/install_pip_package.sh && \
    echo 'import_name="$2"' >> /tmp/install_pip_package.sh && \
    echo '[ -z "$import_name" ] && import_name="$package"' >> /tmp/install_pip_package.sh && \
    echo 'import_name=$(echo "$import_name" | sed "s/-/_/g")' >> /tmp/install_pip_package.sh && \
    echo 'if python -c "import $import_name" 2>/dev/null; then' >> /tmp/install_pip_package.sh && \
    echo '    echo "âœ“ $package already installed, skipping..."' >> /tmp/install_pip_package.sh && \
    echo 'else' >> /tmp/install_pip_package.sh && \
    echo '    echo "Installing $package..."' >> /tmp/install_pip_package.sh && \
    echo '    pip install --break-system-packages "$package"' >> /tmp/install_pip_package.sh && \
    echo 'fi' >> /tmp/install_pip_package.sh && \
    chmod +x /tmp/install_pip_package.sh

# Upgrade pip and install core Python packages (excluding packages that will be installed by pacman)


# Install Go tools
RUN export GOPATH=/go && \
    export PATH=$PATH:$GOPATH/bin && \
    go install github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest && \
    go install github.com/OJ/gobuster/v3@latest && \
    go install github.com/tomnomnom/httprobe@latest && \
    go install github.com/ffuf/ffuf@latest

# Install Nmap and security tools (including theHarvester if available)
RUN pacman -S --noconfirm nmap wpscan nikto sqlmap commix nettacker vuls theharvester

# Install Masscan
RUN pacman -S --noconfirm masscan

# Install Wfuzz
RUN pacman -S --noconfirm wfuzz

# Install WhatWeb
RUN pacman -S --noconfirm whatweb

# Install Dirb
RUN pacman -S --noconfirm dirb

# Install Dirbuster
RUN pacman -S --noconfirm dirbuster

# Install Skipfish
RUN pacman -S --noconfirm skipfish

# Install Wapiti
RUN pacman -S --noconfirm wapiti

# Install SSL tools
RUN pacman -S --noconfirm \
        testssl.sh \
        sslscan

# Install additional Python security tools using the helper script (only packages not available via pacman)
RUN /tmp/install_pip_package.sh dirsearch && \
    /tmp/install_pip_package.sh httpx-python httpx && \
    /tmp/install_pip_package.sh photon && \
    /tmp/install_pip_package.sh jsbeautifier && \
    /tmp/install_pip_package.sh pyjsparser 
    

RUN pip install --upgrade pip --break-system-packages && \
    /tmp/install_pip_package.sh requests && \
    /tmp/install_pip_package.sh lxml && \
    /tmp/install_pip_package.sh python-whois whois && \
    /tmp/install_pip_package.sh cryptography && \
    rm /tmp/install_pip_package.sh


# Install additional Go tools
RUN export GOPATH=/go && \
    export PATH=$PATH:$GOPATH/bin && \
    go install github.com/projectdiscovery/httpx/cmd/httpx@latest && \
    go install github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest && \
    go install github.com/projectdiscovery/naabu/v2/cmd/naabu@latest && \
    go install github.com/tomnomnom/assetfinder@latest && \
    go install github.com/lc/gau/v2/cmd/gau@latest && \
    go install github.com/tomnomnom/waybackurls@latest && \
    go install github.com/hakluke/hakrawler@latest && \
    go install github.com/hakluke/hakrevdns@latest && \
    go install github.com/hakluke/hakoriginfinder@latest && \
    go install github.com/hakluke/hakcheckurl@latest && \
    go install github.com/hakluke/hakip2host@latest 

# Update nuclei templates
RUN /go/bin/nuclei -update-templates

# Create tools directory and copy binaries
RUN mkdir -p /tools && \
    cp -r /opt/* /tools/ 2>/dev/null || true && \
    cp -r /go/bin/* /tools/ 2>/dev/null || true

# Create a script to verify tool installation
RUN echo '#!/bin/bash' > /tools/verify-tools.sh && \
    echo 'echo "Verifying security tools installation..."' >> /tools/verify-tools.sh && \
    echo 'tools=("nmap" "nikto" "sqlmap" "commix" "corsy" "nettacker" "nuclei" "masscan" "testssl.sh" "sslscan")' >> /tools/verify-tools.sh && \
    echo 'for tool in "${tools[@]}"; do' >> /tools/verify-tools.sh && \
    echo '    if command -v "$tool" >/dev/null 2>&1; then' >> /tools/verify-tools.sh && \
    echo '        echo "âœ“ $tool is installed"' >> /tools/verify-tools.sh && \
    echo '    else' >> /tools/verify-tools.sh && \
    echo '        echo "âœ— $tool is not installed"' >> /tools/verify-tools.sh && \
    echo '    fi' >> /tools/verify-tools.sh && \
    echo 'done' >> /tools/verify-tools.sh && \
    chmod +x /tools/verify-tools.sh

# Install Node.js for the API server
RUN pacman -S --noconfirm nodejs npm

# Set proper permissions
RUN chmod -R 755 /tools && \
    chmod -R +x /tools/*.py 2>/dev/null || true && \
    chmod -R +x /tools/*.pl 2>/dev/null || true

# Create tools API directory structure
RUN mkdir -p /tools/api && \
    mkdir -p /tools/api/src && \
    mkdir -p /tools/logs && \
    mkdir -p /tools/reports

# Create package.json for the tools API
RUN cat > /tools/api/package.json <<'EOF'
{
  "name": "vulscan-tools-api",
  "version": "1.0.0",
  "description": "API server for vulnerability scanning tools",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "node src/server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "express-rate-limit": "^6.8.1",
    "uuid": "^9.0.0",
    "winston": "^3.10.0"
  }
}
EOF

# Install Node.js dependencies for the API
WORKDIR /tools/api
RUN npm install --production

# Create the main API server
RUN cat > /tools/api/src/server.js <<'EOF'
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { spawn } = require('child_process');
const { v4: uuidv4 } = require('uuid');
const winston = require('winston');
const fs = require('fs').promises;
const path = require('path');

// Configure logging
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: '/tools/logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: '/tools/logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

const app = express();
const PORT = process.env.TOOLS_API_PORT || 3001;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json({ limit: '10mb' }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);

// Store active scans
const activeScans = new Map();

// Tool configurations
const TOOLS = {
  nmap: {
    binary: 'nmap',
    defaultArgs: [],
    timeout: 300000, // 5 minutes
    category: 'network'
  },
  nikto: {
    binary: 'nikto',
    defaultArgs: [],
    timeout: 600000, // 10 minutes
    category: 'web'
  },
  nuclei: {
    binary: 'nuclei',
    defaultArgs: [],
    timeout: 900000, // 15 minutes
    category: 'web'
  },
  testssl: {
    binary: 'testssl.sh',
    defaultArgs: [],
    timeout: 300000, // 5 minutes
    category: 'crypto'
  },
  sslscan: {
    binary: 'sslscan',
    defaultArgs: [],
    timeout: 180000, // 3 minutes
    category: 'crypto'
  },
  sqlmap: {
    binary: 'sqlmap',
    defaultArgs: ['--batch'],
    timeout: 1800000, // 30 minutes
    category: 'web'
  },
  dirsearch: {
    binary: 'python3',
    defaultArgs: ['-m', 'dirsearch'],
    timeout: 900000, // 15 minutes
    category: 'web'
  },
  gobuster: {
    binary: 'gobuster',
    defaultArgs: [],
    timeout: 600000, // 10 minutes
    category: 'web'
  },
  whatweb: {
    binary: 'whatweb',
    defaultArgs: [],
    timeout: 180000, // 3 minutes
    category: 'web'
  },
  masscan: {
    binary: 'masscan',
    defaultArgs: [],
    timeout: 600000, // 10 minutes
    category: 'network'
  }
};

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    activeScans: activeScans.size
  });
});

// Get available tools
app.get('/api/tools', async (req, res) => {
  try {
    const toolStatus = {};
    
    for (const [name, config] of Object.entries(TOOLS)) {
      try {
        const version = await getToolVersion(config.binary);
        toolStatus[name] = {
          available: true,
          version,
          category: config.category,
          binary: config.binary
        };
      } catch (error) {
        toolStatus[name] = {
          available: false,
          error: error.message,
          category: config.category,
          binary: config.binary
        };
      }
    }
    
    res.json({
      tools: toolStatus,
      categories: [...new Set(Object.values(TOOLS).map(t => t.category))]
    });
  } catch (error) {
    logger.error('Error getting tools:', error);
    res.status(500).json({ error: 'Failed to get tools information' });
  }
});

// Execute tool command
app.post('/api/execute', async (req, res) => {
  try {
    const { tool, args = [], target, scanId = uuidv4(), timeout } = req.body;
    
    if (!tool || !TOOLS[tool]) {
      return res.status(400).json({ error: 'Invalid or unsupported tool' });
    }
    
    if (!target) {
      return res.status(400).json({ error: 'Target is required' });
    }
    
    const toolConfig = TOOLS[tool];
    const executionId = uuidv4();
    const startTime = Date.now();
    
    logger.info(`Starting execution: ${tool} for target: ${target}`, {
      executionId,
      scanId,
      tool,
      target
    });
    
    // Prepare command arguments
    const commandArgs = [...toolConfig.defaultArgs, ...args];
    
    // Add target to arguments (tool-specific logic)
    if (tool === 'nmap') {
      commandArgs.push(target);
    } else if (tool === 'nikto') {
      commandArgs.push('-h', target);
    } else if (tool === 'nuclei') {
      commandArgs.push('-u', target);
    } else if (tool === 'testssl') {
      commandArgs.push(target);
    } else if (tool === 'sslscan') {
      commandArgs.push(target);
    } else if (tool === 'sqlmap') {
      commandArgs.push('-u', target);
    } else if (tool === 'dirsearch') {
      commandArgs.push('-u', target);
    } else if (tool === 'gobuster') {
      commandArgs.push('dir', '-u', target);
    } else if (tool === 'whatweb') {
      commandArgs.push(target);
    } else if (tool === 'masscan') {
      commandArgs.push(target);
    } else {
      commandArgs.push(target);
    }
    
    // Execute the tool
    const result = await executeCommand(
      toolConfig.binary,
      commandArgs,
      timeout || toolConfig.timeout,
      executionId
    );
    
    const executionTime = Date.now() - startTime;
    
    logger.info(`Execution completed: ${tool}`, {
      executionId,
      scanId,
      tool,
      executionTime,
      exitCode: result.exitCode
    });
    
    res.json({
      executionId,
      scanId,
      tool,
      target,
      success: result.exitCode === 0,
      exitCode: result.exitCode,
      output: result.output,
      error: result.error,
      executionTime,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('Execution error:', error);
    res.status(500).json({
      error: 'Tool execution failed',
      details: error.message
    });
  }
});

// Execute multiple tools (scan mode)
app.post('/api/scan', async (req, res) => {
  try {
    const { tools, target, scanId = uuidv4(), mode = 'parallel' } = req.body;
    
    if (!tools || !Array.isArray(tools) || tools.length === 0) {
      return res.status(400).json({ error: 'Tools array is required' });
    }
    
    if (!target) {
      return res.status(400).json({ error: 'Target is required' });
    }
    
    const scanStartTime = Date.now();
    
    logger.info(`Starting scan mode: ${mode}`, {
      scanId,
      target,
      tools: tools.map(t => t.tool || t),
      mode
    });
    
    // Store scan in active scans
    activeScans.set(scanId, {
      status: 'running',
      startTime: scanStartTime,
      target,
      tools,
      mode
    });
    
    let results = [];
    
    if (mode === 'parallel') {
      // Execute tools in parallel
      const promises = tools.map(toolConfig => {
        const toolName = typeof toolConfig === 'string' ? toolConfig : toolConfig.tool;
        const toolArgs = typeof toolConfig === 'object' ? toolConfig.args || [] : [];
        
        return executeToolSafe(toolName, toolArgs, target, scanId);
      });
      
      results = await Promise.allSettled(promises);
      results = results.map((result, index) => ({
        tool: typeof tools[index] === 'string' ? tools[index] : tools[index].tool,
        success: result.status === 'fulfilled',
        ...result.value || { error: result.reason?.message }
      }));
      
    } else {
      // Execute tools sequentially
      for (const toolConfig of tools) {
        const toolName = typeof toolConfig === 'string' ? toolConfig : toolConfig.tool;
        const toolArgs = typeof toolConfig === 'object' ? toolConfig.args || [] : [];
        
        try {
          const result = await executeToolSafe(toolName, toolArgs, target, scanId);
          results.push({ tool: toolName, success: true, ...result });
        } catch (error) {
          results.push({ 
            tool: toolName, 
            success: false, 
            error: error.message 
          });
        }
      }
    }
    
    const totalExecutionTime = Date.now() - scanStartTime;
    
    // Update scan status
    activeScans.set(scanId, {
      ...activeScans.get(scanId),
      status: 'completed',
      endTime: Date.now(),
      results
    });
    
    logger.info(`Scan completed`, {
      scanId,
      totalExecutionTime,
      successfulTools: results.filter(r => r.success).length,
      totalTools: results.length
    });
    
    res.json({
      scanId,
      target,
      mode,
      totalExecutionTime,
      results,
      summary: {
        total: results.length,
        successful: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length
      },
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.error('Scan error:', error);
    
    if (req.body.scanId) {
      activeScans.set(req.body.scanId, {
        ...activeScans.get(req.body.scanId),
        status: 'failed',
        error: error.message
      });
    }
    
    res.status(500).json({
      error: 'Scan execution failed',
      details: error.message
    });
  }
});

// Get scan status
app.get('/api/scan/:scanId', (req, res) => {
  const { scanId } = req.params;
  const scan = activeScans.get(scanId);
  
  if (!scan) {
    return res.status(404).json({ error: 'Scan not found' });
  }
  
  res.json({
    scanId,
    ...scan,
    duration: scan.endTime ? scan.endTime - scan.startTime : Date.now() - scan.startTime
  });
});

// Get all active scans
app.get('/api/scans', (req, res) => {
  const scans = Array.from(activeScans.entries()).map(([id, scan]) => ({
    scanId: id,
    ...scan,
    duration: scan.endTime ? scan.endTime - scan.startTime : Date.now() - scan.startTime
  }));
  
  res.json({ scans });
});

// Helper function to get tool version
async function getToolVersion(binary) {
  return new Promise((resolve, reject) => {
    const process = spawn(binary, ['--version'], { 
      timeout: 5000,
      stdio: ['ignore', 'pipe', 'pipe']
    });
    
    let output = '';
    let error = '';
    
    process.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    process.stderr.on('data', (data) => {
      error += data.toString();
    });
    
    process.on('close', (code) => {
      if (code === 0 || output.length > 0) {
        const version = (output + error).split('\n')[0].trim();
        resolve(version);
      } else {
        reject(new Error(`Tool not available: ${binary}`));
      }
    });
    
    process.on('error', (err) => {
      reject(new Error(`Tool execution error: ${err.message}`));
    });
  });
}

// Helper function to execute a command safely
async function executeToolSafe(tool, args, target, scanId) {
  if (!TOOLS[tool]) {
    throw new Error(`Unsupported tool: ${tool}`);
  }
  
  const toolConfig = TOOLS[tool];
  const commandArgs = [...toolConfig.defaultArgs, ...args];
  
  // Add target to arguments (same logic as above)
  if (tool === 'nmap') {
    commandArgs.push(target);
  } else if (tool === 'nikto') {
    commandArgs.push('-h', target);
  } else if (tool === 'nuclei') {
    commandArgs.push('-u', target);
  } else if (tool === 'testssl') {
    commandArgs.push(target);
  } else if (tool === 'sslscan') {
    commandArgs.push(target);
  } else if (tool === 'sqlmap') {
    commandArgs.push('-u', target);
  } else if (tool === 'dirsearch') {
    commandArgs.push('-u', target);
  } else if (tool === 'gobuster') {
    commandArgs.push('dir', '-u', target);
  } else if (tool === 'whatweb') {
    commandArgs.push(target);
  } else if (tool === 'masscan') {
    commandArgs.push(target);
  } else {
    commandArgs.push(target);
  }
  
  return executeCommand(toolConfig.binary, commandArgs, toolConfig.timeout, `${scanId}-${tool}`);
}

// Helper function to execute a command
async function executeCommand(binary, args, timeout, executionId) {
  return new Promise((resolve, reject) => {
    logger.info(`Executing: ${binary} ${args.join(' ')}`, { executionId });
    
    const process = spawn(binary, args, {
      timeout,
      stdio: ['ignore', 'pipe', 'pipe'],
      cwd: '/tools'
    });
    
    let output = '';
    let error = '';
    
    process.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    process.stderr.on('data', (data) => {
      error += data.toString();
    });
    
    const timeoutHandler = setTimeout(() => {
      process.kill('SIGTERM');
      reject(new Error('Command timeout'));
    }, timeout);
    
    process.on('close', (code) => {
      clearTimeout(timeoutHandler);
      resolve({
        exitCode: code,
        output: output.trim(),
        error: error.trim()
      });
    });
    
    process.on('error', (err) => {
      clearTimeout(timeoutHandler);
      reject(new Error(`Process error: ${err.message}`));
    });
  });
}

// Start server
app.listen(PORT, '0.0.0.0', () => {
  logger.info(`Tools API server started on port ${PORT}`);
  console.log(`ðŸ”§ Tools API Server running on http://0.0.0.0:${PORT}`);
  console.log(`ðŸ“Š Health check: http://0.0.0.0:${PORT}/health`);
  console.log(`ðŸ› ï¸  Available tools: http://0.0.0.0:${PORT}/api/tools`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');
  process.exit(0);
});
EOF

# Create an enhanced entrypoint script
RUN cat > /tools/entrypoint.sh <<'EOF'
#!/bin/bash
set -e

echo "ðŸ”§ Security Tools Container with API Server"
echo "============================================="

# Create necessary directories
mkdir -p /tools/logs /tools/reports

# Start the API server in the background if requested
if [ "$START_API" = "true" ] || [ "$1" = "api" ]; then
    echo "ðŸš€ Starting Tools API Server..."
    cd /tools/api
    npm start &
    API_PID=$!
    echo "ðŸ“¡ API Server started with PID: $API_PID"
    echo "ðŸŒ API available at: http://localhost:3001"
    
    # If api command, wait for the API server
    if [ "$1" = "api" ]; then
        echo "â³ Waiting for API server..."
        wait $API_PID
        exit $?
    fi
fi

# List available tools
echo "ðŸ“‹ Available Security Tools:"
echo "   Network: nmap, masscan"
echo "   Web: nikto, nuclei, whatweb, dirsearch, gobuster"
echo "   Crypto: testssl.sh, sslscan"
echo "   Database: sqlmap"
echo

# Execute the passed command or default to bash
if [ $# -eq 0 ]; then
    echo "ðŸš Starting interactive shell..."
    exec bash
else
    echo "â–¶ï¸  Executing: $@"
    exec "$@"
fi
EOF

RUN chmod +x /tools/entrypoint.sh

# Set working directory
WORKDIR /tools

# Expose API port
EXPOSE 3001

# Default entrypoint and command
ENTRYPOINT ["/tools/entrypoint.sh"]
CMD ["api"]
